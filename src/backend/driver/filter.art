
fn distance(x : i32, y : i32, i : i32, j : i32) = math_builtins::sqrt((x - i) * (x - i) + (y - j) * (y - j)) as f32;

// // Need to change exp = 2.718 to something more accurate if possible
fn gaussian(x : f32, sigma : f32) -> f32{
    // let ind : f32 = x as f32;
    let abs_x = x;//math_builtins::fabs(x);
    let norm = (1.0 / (2 * flt_pi * (sigma * sigma))); ////(math_builtins::sqrt(2 * flt_pi) * sigma)
    let expo = -1.0 * (abs_x * abs_x) / (2.0 * sigma * sigma);
    let result = norm * math_builtins::exp(expo);
    result
}

fn compute_luminance_weight(lp : f32, lq : f32, variance : f32, sigma_c : f32) -> f32{
    let diff = lp - lq;
    let distance = math_builtins::fabs(diff);
    let eval = -distance / (math_builtins::sqrt(variance) * sigma_c + 1e-6);
    let weight = math_builtins::exp(eval);
    weight
}

fn compute_normal_depth_weight(n_p : Vec3, n_q : Vec3, sigma : f32) -> f32{
    // same function for both weights- inputs differ
    let diff = vec3_sub(n_p, n_q);
    let distance = vec3_len(diff);
    let eval = -distance / (sigma + 1e-6);
    let weight = math_builtins::fmin(1.0 as f32, math_builtins::exp(eval));
    weight
}

fn get_pixel_value(ind_q : i32, buffer : DeviceBuffer, width : i32, height : i32) -> f32{
    // for border handling
    // ind_p - center pixel, ind_q - neighbour
    // let value = 0.0 as f32;//frame_buffer.load_f32(ind_q);
    // value
    if((ind_q >= 0) && (ind_q <= (width) * (height) * 3 + 1)){
        let val = buffer.load_f32(ind_q);
        if(!math_builtins::isnan(val)){val}
        else{0.0 as f32}
    }
    else{0.0 as f32}

    // buffer.load_f32(ind_q)
}

fn get_vector_from_buffer(ind : i32, buffer : DeviceBuffer, width : i32, height : i32) -> Vec3{
    // for border handling
    // ind_p - center pixel, ind_q - neighbour

    // takes care of right and left borders too
    if((ind >= 0) && (ind <= (width) * (height) * 3 + 1)){
        if((ind) % 3 == 0){
            let nx = buffer.load_f32(ind);
            let ny = buffer.load_f32(ind + 1);
            let nz = buffer.load_f32(ind + 2);
            make_vec3(nx, ny, nz)
        }
        else if((ind) % 3 == 1){
            let nx = buffer.load_f32(ind - 1);
            let ny = buffer.load_f32(ind);
            let nz = buffer.load_f32(ind + 1);
            make_vec3(nx, ny, nz)
        }
        else{
            let nx = buffer.load_f32(ind - 2);
            let ny = buffer.load_f32(ind - 1);
            let nz = buffer.load_f32(ind);
            make_vec3(nx, ny, nz)
        }
    }
    else{
        make_vec3(0.0, 0.0, 0.0)
    }
}

fn isReprjValid(width : i32, height : i32, prev_coord : i32, curr_normal : Vec3, prev_normal : Vec3, curr_depth : Vec3, prev_depth : Vec3) -> bool {
    // let p = curr_coord.x + curr_coord.y * width * 3;
    // let q = prev_coord.x + prev_coord.y * width * 3;
    // check if the pixel is inside the screen
    if((prev_coord < 0) || (prev_coord > (width * height * 3))){
        return(false)
    }

    // // check deviation in depth
    let diff_depth = vec3_sub(prev_depth, curr_depth);
    let distance_depth = vec3_len(diff_depth);
    if(distance_depth > (0.1 as f32)){
        return(false)
    }

    // // check deviation in normal
    let diff_normal = vec3_sub(prev_normal, curr_normal);
    let distance_normal = vec3_len(diff_normal);
    if(distance_normal > (0.1 as f32)){
        return(false)
    }

    true
}

#[export]
fn BackProjection(device_id: i32, in_pixels: &[f32], normals: &[f32], depth: &[f32], width: i32, height: i32) -> (){
    // TODO //probably can be done independently

    let device = @get_device(device_id);
    // create a bunch of buffers moment_acc, variance_out, color_acc, history_length(if necessary) (everything is accumulated index wise(for each pixel))
    let buffer_out = device.make_buffer(in_pixels as &[u8],  width * height * 3); 
    let buffer_n = device.make_buffer(normals as &[u8], width * height * 3);
    let buffer_d = device.make_buffer(depth as &[u8], width * height * 3);
    
    
    let buffer_in = device.request_buffer("__input_buffer", width * height * 3, 0); //c_(i)
    let buffer_normals = device.request_buffer("__normals_buffer", width * height * 3, 0);
    let buffer_depth = device.request_buffer("__depth_buffer", width * height * 3, 0);
    let buffer_lum = device.request_buffer("__luminance_buffer", width * height * 3, 0);
    let prev_buffer_normals = device.request_buffer("__normals_buffer", width * height * 3, 0);
    let prev_buffer_depth = device.request_buffer("__depth_buffer", width * height * 3, 0);

    let color_history_buffer = device.request_buffer("__color_history_buffer", width * height * 3, 0);
    let variance_history_buffer = device.request_buffer("__variance_history_buffer", width * height * 3, 0);
    let mean_history_buffer = device.request_buffer("__mean_history_buffer", width * height * 3, 0);

    let color_acc_buffer = device.request_buffer("__color_acc_buffer", width * height * 3, 0);
    let mean_acc_buffer = device.request_buffer("__mean_acc_buffer", width * height * 3, 0);
    let second_moment_acc_buffer = device.request_buffer("__second_moment_acc_buffer", width * height * 3, 0);
    let variance_out_buffer = device.request_buffer("__variance_out_buffer", width * height * 3, 0);


    let color_alpha_min = 0.2 as f32;
    let mean_alpha_min = 0.2 as f32;
    let second_moment_alpha_min = 0.2 as f32;

    for ind in device.parallel_range(0, (width) * (height) * 3 + 1) {
        let out = get_pixel_value(ind, buffer_out, width, height);// buffer_out.load_f32(ind);
        buffer_in.store_i32(ind, bitcast[i32](out));
        let norml = get_pixel_value(ind, buffer_n, width, height);//buffer_n.load_f32(ind);
        buffer_normals.store_i32(ind, bitcast[i32](norml));
        
        let dep = get_pixel_value(ind, buffer_d, width, height);//buffer_d.load_f32(ind);
        buffer_depth.store_i32(ind, bitcast[i32](dep));
    }
    device.sync();

    ///////// calculating luminance buffer
    for ind in device.parallel_range(0, (width-1) * (height-1) * 3) {
        let rgb = get_vector_from_buffer(ind, buffer_in, width, height);
        let color = make_color(rgb.x, rgb.y, rgb.z, 1);
        let lum_val = color_luminance(color);
        buffer_lum.store_i32(ind, bitcast[i32](lum_val));
    }
    /////////

    // history_length buffer 
    /// current view matrix....to get calculate prev_view storing it later lets go to the future
    // let up_buf = device.make_buffer(up as &[u8], 3);
    // let dir_buf = device.make_buffer(dir as &[u8], 3);
    let up_v = vec3_normalize(registry::get_parameter_vec3("__camera_up", make_vec3(0.0, 0.0, 0.0)));
    let dir_v = vec3_normalize(registry::get_parameter_vec3("__camera_dir", make_vec3(0.0, 0.0, 0.0)));

    let curr_up_buf = device.request_buffer("__current_cam_up", 3, 0);
    let curr_dir_buf = device.request_buffer("__current_cam_dir", 3, 0);
    let prev_up_buf = device.request_buffer("__prev_cam_up", 3, 0);
    let prev_dir_buf = device.request_buffer("__prev_cam_dir", 3, 0);
   
    for i in unroll(0,3){
        curr_up_buf.store_i32(i, bitcast[i32](vec3_at(up_v, i)));
        curr_dir_buf.store_i32(i, bitcast[i32](vec3_at(dir_v, i)));
    }
    let curr_view_mat = get_view_matrix(curr_up_buf, curr_dir_buf);
    let mut prev_view_mat : Mat3x3;

    ///////
    let history_length = device.request_buffer("__history_length", width * height * 3 + 1, 0);// last index is used for counting iterations(dummy)
    let which_iter = history_length.load_f32(width * height * 3 + 1);

    if(which_iter == 0){
        for ind in device.parallel_range(0, (width) * (height) * 3 + 1) {
            let norml = get_pixel_value(ind, buffer_n, width, height);
            prev_buffer_normals.store_i32(ind, bitcast[i32](norml));
            let dep = get_pixel_value(ind, buffer_d, width, height);//buffer_d.load_f32(ind);
            prev_buffer_depth.store_i32(ind, bitcast[i32](dep));
        }
        //storing view in buffers for use in next frame
        for i in unroll(0,3){
            prev_up_buf.store_i32(i, bitcast[i32](vec3_at(up_v, i)));
            prev_dir_buf.store_i32(i, bitcast[i32](vec3_at(dir_v, i)));
        }
        // prev_view_mat = curr_view_mat;
        history_length.store_i32(width * height * 3 + 1, bitcast[i32](1));
    }

    for ind in unroll(0, (width-1) * (height-1) * 3) {
        let N = history_length.load_f32(ind);
        let lum = buffer_lum.load_f32(ind);
        if(N > 0){ //N will be < 0 at the first iteration so there's no prev_view
            //calculating NDC coordinates in previous frame
            prev_view_mat = get_view_matrix(prev_up_buf, prev_dir_buf);
            let curr_position = get_vector_from_buffer(ind, buffer_depth, width, height);
            let viewspace_position = mat3x3_mul(prev_view_mat, curr_position);
            let clipx = viewspace_position.x / viewspace_position.z;
            let clipy = viewspace_position.y / viewspace_position.z;
            let ndcx = -clipx * (0.5 as f32) + (0.5 as f32);
            let ndcy = -clipy * (0.5 as f32) + (0.5 as f32);
            let prevx = ndcx * (width as f32) - (0.5 as f32);
            let prevy = ndcy * (height as f32) - (0.5 as f32);

            
            let mut v:[bool * 4];
            let floorx = math_builtins::floor(prevx);
            let floory = math_builtins::floor(prevy);
            let fracx = prevx - floorx;
            let fracy = prevy - floory;

            // checking with 2x2 tap bilinear filter for neighbouring samples
            let offset = [make_vec2(0 as f32, 0 as f32), make_vec2(1 as f32, 0 as f32), make_vec2(0 as f32, 1 as f32), make_vec2(1 as f32, 1 as f32)];

            let mut valid = (floorx as i32 >= 0) && (floorx as i32 < width) && (floory as i32 >= 0) && (floory as i32 < height);
            let curr_normal = get_vector_from_buffer(ind, buffer_normals, width, height);
            let curr_depth = get_vector_from_buffer(ind, buffer_depth, width, height);
            // best way to move is to just use vec2 in isreprojvalid too 
            // TODO: to convert buffer indices to vec2/vec3 
            for sample_idx in unroll(0, 4){
                let prev_coord_xy = vec2_add(make_vec2(floorx, floory), offset(sample_idx));
                let prev_coord = (prev_coord_xy.y * (width as f32) * 3 + prev_coord_xy.x * 3) as i32;
                let prev_normal = get_vector_from_buffer(prev_coord, buffer_normals, width, height);
                let prev_depth = get_vector_from_buffer(prev_coord, buffer_depth, width, height);
                v(sample_idx) = isReprjValid(width, height, prev_coord, curr_normal, prev_normal, curr_depth, prev_depth);
                valid = valid && v(sample_idx);
            }
            // if considering ind, loop should go *3 
            let mut prev_color = 0.0 as f32; //color value from buffer_in
            let mut prev_mean = 0.0 as f32; // first order moment
            let mut prev_second_moment = 0.0 as f32; // second order moment

            let mut prev_historylength = 0.0 as f32;

            if(valid){
                let mut sumw = 0.0 as f32;
                let w = [((1.0 as f32) - fracx) * ((1.0 as f32) - fracy), fracx * ((1.0 as f32) - fracy), ((1.0 as f32) - fracx) * fracy, fracx * fracy];

                for sample_idx in unroll(0, 4 * 3){
                    let prev_coord_xy = vec2_add(make_vec2(floorx, floory), offset(sample_idx));
                    let prev_coord = (prev_coord_xy.y * (width as f32) * 3 + prev_coord_xy.x * 3) as i32;
                    if(v(sample_idx)){
                        prev_color += w(sample_idx) * color_history_buffer.load_f32(prev_coord); //get_pixel_value(prev_coord, color_history_buffer, width, height)
                        prev_mean += w(sample_idx) * mean_history_buffer.load_f32(prev_coord);
                        prev_second_moment += w(sample_idx) * variance_history_buffer.load_f32(prev_coord);
                        prev_historylength += w(sample_idx) * history_length.load_f32(prev_coord);
                        sumw += w(sample_idx);
                    }
                }
                if( sumw >= 0.01){
                    prev_color /= sumw;
                    prev_second_moment /= sumw;
                    prev_mean /= sumw;
                    prev_historylength /= sumw;
                    valid = true;
                }
            }
            // finding samples elsewhere
            if(!valid){
                let mut cnt = 0.0 as f32;
                let radius = 1;

                for yy in unroll(-radius, radius){
                    for xx in unroll(-radius, radius){
                        let prev_coord_xy = vec2_add(make_vec2(floorx, floory), make_vec2(xx as f32, yy as f32));
                        let prev_coord = (prev_coord_xy.y * (width as f32) * 3 + prev_coord_xy.x * 3) as i32;
                        let prev_normal = get_vector_from_buffer(prev_coord, buffer_normals, width, height);
                        let prev_depth = get_vector_from_buffer(prev_coord, buffer_depth, width, height);
                        let check_valid = isReprjValid(width, height, prev_coord, curr_normal, prev_normal, curr_depth, prev_depth);
                        if(check_valid){
                            prev_color += color_history_buffer.load_f32(prev_coord);
                            prev_mean += mean_history_buffer.load_f32(prev_coord);
                            prev_second_moment += variance_history_buffer.load_f32(prev_coord);
                            prev_historylength += history_length.load_f32(prev_coord);
                            cnt += 1.0 as f32;
                        }
                    }
                }
                if(cnt > 0.0 as f32){
                    prev_color /= cnt;
                    prev_second_moment /= cnt;
                    prev_mean /= cnt;
                    prev_historylength /= cnt;
                    valid = true;
                }
            }
            if(valid){
                // calculating alpha values for fade
                let color_alpha = math_builtins::fmax((1.0 as f32)/((N + 1)), color_alpha_min);
                let mean_alpha = math_builtins::fmax((1.0 as f32)/((N + 1)), mean_alpha_min);
                let second_moment_alpha = math_builtins::fmax((1.0 as f32)/((N + 1)), second_moment_alpha_min);

                // increase history length
                history_length.store_i32(ind, bitcast[i32](prev_historylength + 1));

                // color accumulation
                let color_acc_val = buffer_in.load_f32(ind) * color_alpha + prev_color * ((1.0 as f32) - color_alpha);
                color_acc_buffer.store_i32(ind, bitcast[i32](color_acc_val));

                // moments accumulation
                let first_moment = mean_alpha * prev_mean + ((1.0 as f32) - mean_alpha) * buffer_lum.load_f32(ind);
                let second_moment = second_moment_alpha * prev_second_moment + ((1.0 as f32) - second_moment_alpha) * buffer_lum.load_f32(ind) * buffer_lum.load_f32(ind);
                mean_acc_buffer.store_i32(ind, bitcast[i32](first_moment));
                second_moment_acc_buffer.store_i32(ind, bitcast[i32](second_moment));
                
                // calculate variance from moments
                let variance = second_moment - first_moment * first_moment;
                if(variance > (0.0 as f32)){
                    variance_out_buffer.store_i32(ind, bitcast[i32](variance));
                }
                else{
                    variance_out_buffer.store_i32(ind, bitcast[i32](0.0));
                }
            }
        }
        else{
            history_length.store_i32(ind, bitcast[i32](1));
            // color accumulation
            let color_acc_val = buffer_in.load_f32(ind);
            color_acc_buffer.store_i32(ind, bitcast[i32](color_acc_val));

            // moments accumulation
            let first_moment = buffer_lum.load_f32(ind);
            let second_moment = buffer_lum.load_f32(ind) * buffer_lum.load_f32(ind);
            mean_acc_buffer.store_i32(ind, bitcast[i32](first_moment));
            second_moment_acc_buffer.store_i32(ind, bitcast[i32](second_moment));
            let variance = 100.0 as f32;
            variance_out_buffer.store_i32(ind, bitcast[i32](variance));
        }
    }
    for ind in unroll(0, (width-1) * (height-1) * 3) {
        let out = color_acc_buffer.load_f32(ind);
        buffer_out.store_i32(ind, bitcast[i32](out));
    }
}
// TODO write an outer function thats able to call atrous filter, backprojection, etc
// need to check/ ask if buffers written in other functions can be accessed in another function somehow similar to registry --- answer...yes they can be buffers are just written in memory
  
struct GbufferTexel{
    normal : Vec3,
    position : Vec3,
    albedo : Vec3,
    geomId : i32,
} // not feasible for entire buffers ???


fn get_view_matrix(up_buf : DeviceBuffer, dir_buf : DeviceBuffer) -> Mat3x3{
    let cam_up = make_vec3(up_buf.load_f32(0), up_buf.load_f32(1), up_buf.load_f32(2));
    let cam_dir = make_vec3(dir_buf.load_f32(0), dir_buf.load_f32(1), dir_buf.load_f32(2));

    // view matrix:
    let right = vec3_normalize(vec3_cross(cam_dir, cam_up));
    let view  = mat3x3_invert(make_mat3x3(right, cam_up, cam_dir));
    view
}

#[export]
fn EstimateVariance(device_id: i32, width: i32, height: i32) -> (){
    let device = @get_device(device_id);
    let variance_out_buffer = device.request_buffer("__variance_out_buffer", width * height * 3, 0);
    for ind in unroll(0, (width-1) * (height-1) * 3) {
        let var_val = 10.0 as f32;
        variance_out_buffer.store_i32(ind, bitcast[i32](var_val));
    }
}

#[export]
fn atrousfilter(device_id: i32, in_pixels: &[f32], normals: &[f32], depth: &[f32], albedo: &[f32], width: i32, height: i32, n_levels :i32) -> () {
    let device = @get_device(device_id);

    // Computing buffers
    // in_pixels - pointer to frame_buffer
    let buffer_out = device.make_buffer(in_pixels as &[u8],  width * height * 3); // contains rendered pixels from fb or if multiple_levels of atrous filter- contains filtered output after 1 level
    let buffer_normals = device.make_buffer(normals as &[u8], width * height * 3);
    let buffer_depth = device.make_buffer(depth as &[u8], width * height * 3);
    let buffer_albedo = device.make_buffer(albedo as &[u8], width * height * 3); // not used 

    // bunch of buffers for storing intermediates
    let buffer_in = device.request_buffer("__input_buffer", width * height * 3, 0); //c_(i)
    let intermediate_out_buffer = device.request_buffer("__intermediate_out_buffer", width * height * 3, 0); //c_(i+1)
    let buffer_lum = device.request_buffer("__luminance_buffer", width * height * 3, 0);

    for ind in device.parallel_range(0, (width) * (height) * 3 + 1) {
        let out = get_pixel_value(ind, buffer_out, width, height);// buffer_out.load_f32(ind);
        buffer_in.store_i32(ind, bitcast[i32](out));
    }
    device.sync();

    ///////// calculating luminance buffer
    for ind in device.parallel_range(0, (width-1) * (height-1) * 3) {
        let rgb = get_vector_from_buffer(ind, buffer_in, width, height);
        let color = make_color(rgb.x, rgb.y, rgb.z, 1);
        let lum_val = color_luminance(color);
        buffer_lum.store_i32(ind, bitcast[i32](lum_val));
    }
    /////////

    // 2x2 kernel
    // let ent1 = make_vec2((1.0 / 4.0) as f32, (1.0 / 8.0) as f32);
    // let ent2 = make_vec2((1.0 / 8.0) as f32, (1.0 / 16.0) as f32);
    // let kernel = make_mat2x2(ent1, ent2);

    let col1 = make_vec3(1.0 / 16.0 as f32, 1.0 / 8.0 as f32, 1.0 / 16.0 as f32);
    let col2 = make_vec3(1.0 / 8.0 as f32,  1.0 / 4.0 as f32, 1.0 / 8.0 as f32);
    let gaussian_kernel = make_mat3x3(col1, col2, col1);

    // let gaussian_kernel = [1.0 / 16.0 as f32, 1.0 / 8.0 as f32, 1.0 / 16.0 as f32,
    //                     1.0 / 8.0 as f32,  1.0 / 4.0 as f32, 1.0 / 8.0 as f32,
    //                     1.0 / 16.0 as f32, 1.0 / 8.0 as f32, 1.0 / 16.0 as f32];
    let variance_out_buffer = device.request_buffer("__variance_out_buffer", width * height * 3, 0);
    
    //test
    // for ind in unroll(0, (width-1) * (height-1) * 3) {
    //     let var_val = 10.0 as f32;
    //     variance_out_buffer.store_i32(ind, bitcast[i32](var_val));
    // }
    // let print_val = variance_out_buffer.load_f32(500);
    // print_i32(3334);
    // print_f32(print_val);
    /////
    // Settings for filter

    // initial setting
    // let sigma_rt = 1.0 as f32;
    // let sigma_normal = 2.0 as f32;
    // let sigma_d = 1.0 as f32;
    let kernel_size = 5; //(2 * (4 * sigma_i + 0.5) + 1) as i32;

    // settings 1 based on cuda_denoising //default setting
    let sigma_l = 0.7 as f32;
    let sigma_d = 1 as f32;//0.35 as f32; //ui_sigmax
    let sigma_normal = 128 as f32;//0.2 as f32;

    //settings 2 based on cuda_denoising
    // let sigma_l = 0.45 as f32;
    // let sigma_d = 0.35 as f32; //ui_sigmax
    // let sigma_normal = 0.2 as f32;

    // 5x5 A-Trous kernel
    let h = [1.0 / 256.0, 1.0 / 64.0, 3.0 / 128.0, 1.0 / 64.0, 1.0 / 256.0,
        1.0 / 64.0, 1.0 / 16.0, 3.0 / 32.0, 1.0 / 16.0, 1.0 / 64.0,
        3.0 / 128.0, 3.0 / 32.0, 9.0 / 64.0, 3.0 / 32.0, 3.0 / 128.0,
        1.0 / 64.0, 1.0 / 16.0, 3.0 / 32.0, 1.0 / 16.0, 1.0 / 64.0,
        1.0 / 256.0, 1.0 / 64.0, 3.0 / 128.0, 1.0 / 64.0, 1.0 / 256.0 ];
    
    // let kernel_weights = [1.0 as f32, 2.0/3.0 as f32, 1.0/6.0 as f32];
    
    let radius = ((kernel_size - 1) / 2);
    let stride = n_levels;

    for ind in unroll(0, (width-1) * (height-1) * 3) {
        // blurring variance
        let mut variance_sum_w : f32;
        let mut variance_add : f32;
        variance_sum_w = 0.0 as f32;
        variance_add = 0.0;

        let up_var = 1;
        for j in unroll(up_var * -1, up_var + 1){ // yy
            let row = ind + width * 3 * j;
            for i in unroll(up_var * -1, up_var + 1){ // xx
                let k = mat3x3_at(gaussian_kernel, abs(i), abs(j));
                let val = get_pixel_value(row + j * 3, variance_out_buffer, width, height); // dont know if buffer_in(aka frambuffer is the correct buffer)
                variance_add += val * k;
                variance_sum_w += k;
            }
        }
        let var = math_builtins::fmax(variance_add / variance_sum_w, 0.0 as f32);
        // if(ind == 1200) {print_f32(var);}
        ////////
        
        let mut weights_sum = 0.0 as f32; // weights sum
        let mut color_sum = 0.0 as f32; // color sum
        let mut variance_sum = 0.0 as f32;
        let mut weights_sqrd_sum : f32; // for variance

        let lp = get_pixel_value(ind, buffer_lum, width, height); // luminance
        let pp = get_vector_from_buffer(ind, buffer_depth, width, height); //position
        let np = get_vector_from_buffer(ind, buffer_normals, width, height); //normal
        // let variance_p = get_pixel_value(ind, variance_buffer, width, height);
        
        for i in unroll (radius * -1, radius + 1){
            let row = ind + stride * width * 3 * i;
            for j in unroll (radius * -1, radius + 1){
                let q = row + stride * j * 3; //neighbour
                let lq = get_pixel_value(q, buffer_lum, width, height);
                let pq = get_vector_from_buffer(q, buffer_depth, width, height);
                let nq = get_vector_from_buffer(q, buffer_normals, width, height);

                // edge stopping weights
                let wl = compute_luminance_weight(lp, lq, var, sigma_l);
                let wn = compute_normal_depth_weight(np, nq, sigma_normal);
                let wd = compute_normal_depth_weight(pp, pq, sigma_d);

                // filter weights
                let k = (radius + i) + (radius + j) * kernel_size; // index to sample from h(the atrous kernel)
                let weight = (h(k) as f32) * wn * wd * wl; // check luminance buffer
                weights_sum += weight;
                weights_sqrd_sum += weight * weight;
                let buf_value = get_pixel_value(q, buffer_in, width, height);
                color_sum += (buf_value * weight);

                let variance_q = get_pixel_value(q, variance_out_buffer, width, height);
                variance_sum += (variance_q * weight * weight);
            }
        }
        // update color and variance

        if(weights_sum > 10e-6){
            let out = color_sum / weights_sum;
            intermediate_out_buffer.store_i32(ind, bitcast[i32](out)); // convolved result / final convolution that needs to be added at iteration N 
            // let var_update = variance_sum / weights_sqrd_sum;
            // variance_out_buffer.store_i32(ind, bitcast[i32](var_update));
        }
        else{
            let out = buffer_in.load_f32(ind);
            intermediate_out_buffer.store_i32(ind, bitcast[i32](out));
        }
    }
    device.sync();

    // writing to output- framebuffer
    for ind in device.parallel_range(0, (width-1) * (height-1) * 3) {
        let out = intermediate_out_buffer.load_f32(ind);
        buffer_out.store_i32(ind, bitcast[i32](out)); //math_builtins::fabs(org)

    }

    device.present();
    device.sync();
}