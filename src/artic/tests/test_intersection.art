fn test_tri_intersect() {
    let mut err = 0;

    let tri = make_tri(make_vec3(0,0,0), make_vec3(-1,0,0), make_vec3(0,1,0), make_vec3(0,0,-1));
    let ray = make_ray(make_vec3(0.2,0.4,1), make_vec3(0,0,-1), 0, 10);
    
    //ignis_dbg_echo_vec3(tri.v1);
    //ignis_dbg_echo_vec3(tri.v2);
    if let Option[(f32, f32, f32)]::Some((t, u, v)) = intersect_ray_tri(cpu_intrinsics, false, ray, tri) {
        if !eq_f32(t, 1) || !eq_f32(u, 0.2) || !eq_f32(v, 0.4){
            ++err;
        }
    } else {
        ++err;
        ignis_test_fail("Triangle was not intersected!");
    }

    err  
}

fn test_bbox_intersect() {
    let mut err = 0;

    let tbbox = make_tagged_bbox(make_vec3(0,0,0), make_vec3(1,1,1), 0);
    let ray = make_ray(make_vec3(0.2,0.4,2), make_vec3(0,0,-1), 0, 10);
    let defminmax = make_default_min_max();

    if let Option[f32]::Some(t) = intersect_ray_tagged_box(defminmax, ray, tbbox) {
        if !eq_f32(t, 1) {
            ++err;
        }
    } else {
        ++err;
        ignis_test_fail("BBox was not intersected!");
    }

    err
}

#[export] fn test_intersection() -> i32 { 
    let mut err = 0;

    err += test_tri_intersect();
    err += test_bbox_intersect();

    err
 }